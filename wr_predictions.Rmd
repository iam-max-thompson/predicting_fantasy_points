---
title: "wr_predictions"
output: html_document
date: "2023-10-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(nflverse)
library(caret)
library(zoo)
library(plotly)
library(DALEX)
library(visdat)
library(gbm)
library(groupdata2)
library("rvest")
library("xml2")
# if you set the wd to our folder itll all run assuming you have the updated github files
setwd("/Users/max/Desktop/predicting_fantasy_points")
```


```{r}
# load_player_stats gives us weekly stats for every player from year:year
d2010_to_2022 <- load_player_stats(c(2012:2023))


# filters for relevant players and regular season + relevant columns
wrs <- d2010_to_2022 %>% filter(position %in% c("TE", "WR")) %>% filter(season_type == "REG") %>% select(player_id, player_name, recent_team, season, week, receptions, targets, receiving_yards, receiving_tds, receiving_fumbles_lost, receiving_air_yards, receiving_yards_after_catch, target_share, fantasy_points_ppr, position, wopr, receiving_air_yards, receiving_epa)

# turns each row into 1 player, 1 season 
wr_by_season <- wrs %>% group_by(player_id, season) %>% summarize(total_pts = sum(fantasy_points_ppr), total_games = n(), total_targets = sum(targets), total_wopr = sum(wopr),
total_rec = sum(receptions), total_epa = sum(receiving_epa),
total_air_yards = sum(receiving_air_yards))


```


```{r}
# gotta get pfr_player_ids into wr_by_season 
player_ids <- load_ff_playerids() %>% select(pfr_id, gsis_id) %>% rename(pro_fr_id = pfr_id)

# adding in pfr_player_id 
wr_by_season <- wr_by_season %>% left_join(player_ids, by = c("player_id" = "gsis_id"))

# load in manually found pfr ids
missing_pfr_players_guess <- read_csv("missing_pfr_players_guess.csv")

# add in manually found pfr ids
wr_by_season <- wr_by_season %>% left_join(select(missing_pfr_players_guess, -display_name, -rookie_year), by = "player_id")

# create "new_pfr_id to combine old + new pfr_ids"
wr_by_season$new_pfr_id <- ifelse(is.na(wr_by_season$pro_fr_id), wr_by_season$estimated_pfr_id, wr_by_season$pro_fr_id)

#loading in the manually fixed pfr id
wrong_pfr_to_fix <- read_csv("wrong_pfr_to_fix.csv")

# if new_pfr_id is in wrong_pfr, replace
wr_by_season <- wr_by_season %>% left_join(select(wrong_pfr_to_fix, display_name, fixed_pfr_id, old_pfr_id), by = c("new_pfr_id" = "old_pfr_id")) %>% mutate(new_pfr_id = coalesce(fixed_pfr_id, new_pfr_id))

# how many wrs dont have a pfr id??
sum(is.na(wr_by_season$new_pfr_id))
# no missing gsis ids tho
sum(is.na(wr_by_season$player_id))

# adding in snap count info
snaps <- load_snap_counts(seasons = c(2012:2023))

# getting total snaps for each player for each season
snaps_by_season <- snaps %>% 
filter(game_type == "REG", offense_snaps > 0) %>% 
  mutate(total_snaps = offense_snaps / offense_pct) %>% group_by(pfr_player_id, season) %>% summarize(season_snaps = sum(offense_snaps), avg_snap_rate = mean(total_snaps, na.rm = T),
snap_games_played = n())

# can check this dataframe to see if 2 players have 1 pfr_id
checking_repeat_pfr_ids <- wr_by_season %>% group_by(new_pfr_id) %>% summarize(number_players_sameID = n_distinct(player_id))

duplicates <- wr_by_season %>% filter(new_pfr_id %in% c("JohnCa00", "MattJo00", "MorgJo00" , "ConkTy00"))

# for ConkTy (tyler conklin) he is incorrectly stored as izzory00 (ryan izzo)
#JohnCa00 <- JohnCa03
#MattJo00 <- MattJo22
#MorgJo00 <- MorgJo01
johnca_row <- which(wr_by_season$estimated_pfr_id == "JohnCa00")
wr_by_season$new_pfr_id[johnca_row] <- "JohnCa03"

mattjo_row <- which(wr_by_season$estimated_pfr_id == "MattJo00")
wr_by_season$new_pfr_id[mattjo_row] <- "MattJo22"

morgjo_row <- which(wr_by_season$estimated_pfr_id == "MorgJo00")
wr_by_season$new_pfr_id[morgjo_row] <- "MorgJo01"

izzo_row <- which(wr_by_season$pro_fr_id == "ConkTy00")
wr_by_season$new_pfr_id[izzo_row] <- "IzzoRy00"

# rerun this to make sure that max = 1
print(wr_by_season %>% group_by(new_pfr_id) %>% summarize(number_players_sameID = n_distinct(player_id)) %>% arrange(desc(number_players_sameID)) %>% head(5))


wr_by_season <- wr_by_season %>% left_join(snaps_by_season, by = c("season", c("new_pfr_id" = "pfr_player_id")))


## plotting snaps by targets
# post 2012 ??
post2012 <- wr_by_season %>% filter(season > 2011)
ggplot(post2012, aes(x=season_snaps, y = total_targets)) + geom_point() + geom_smooth()


nas <- post2012 %>% filter(is.na(season_snaps))

#double check to see if the na players have snap counts in load_snap_counts 
snaps_by_season %>% filter(pfr_player_id %in% nas$new_pfr_id)

# the HardDe09 exception -- only guy missing snaps
# going to fill with 100 snaps as to not kill the pts per snap calculation
names(wr_by_season)
wr_by_season$season_snaps <- na.fill(wr_by_season$season_snaps, fill = 100)


# now that we have snaps, lets make out snap-related stats
wr_by_season <- wr_by_season %>% mutate(pts_per_snap = total_pts / (season_snaps+100), targets_per_snap = total_targets / (season_snaps+100), wopr_per_snap = total_wopr / (season_snaps+100),
catch_rate =  total_rec / (total_targets+10))

# turns each row into 1 player, 1 season 
wr_by_season <- wr_by_season %>% mutate(points_per_game = total_pts / snap_games_played, targets_per_game = total_targets / snap_games_played, wopr_per_game = total_wopr / snap_games_played, epa_per_game = total_epa / snap_games_played, air_yards_per_game = total_air_yards / snap_games_played)

```


```{r}
# making the "MASTER" dataframe
MASTER <- wr_by_season %>%
  # THE TEBOW EXCLUSION:
  filter(player_id != "00-0027876") %>%
  arrange(player_id, season) %>%
  group_by(player_id) %>%
  # making "last year" type stats
  mutate(points_pg_ly = lag(points_per_game),
         targets_ly = lag(total_targets),
         targets_pg_ly = lag(targets_per_game),
         total_games_ly = lag(snap_games_played),
         points_2y = lag(points_per_game, n=2),
         targets_2y = lag(total_targets, n=2),
         targets_pg_2y = lag(targets_per_game, n=2),
         total_games_2y = lag(snap_games_played, n=2),
         points_3y = lag(points_per_game, n=3),
         targets_3y = lag(total_targets, n=3),
         targets_pg_3y = lag(targets_per_game, n=3),
         total_games_3y = lag(snap_games_played, n=3),
         epa_pg_ly = lag(epa_per_game, n=1),
         wopr_pg_ly = lag(wopr_per_game, n=1),
         air_yards_pg_ly = lag(air_yards_per_game, n=1),
         wopr_pg_2y = lag(wopr_per_game, n=2),
         wopr_pg_3y = lag(wopr_per_game, n=2),
         points_per_snap_ly = lag(pts_per_snap),
         targets_per_snap_ly = lag(targets_per_snap),
         wopr_per_snap_ly = lag(wopr_per_snap),
         total_snaps_ly = lag(season_snaps),
         catch_rate_ly = lag(catch_rate),
         total_pts_ly = lag(total_pts)) %>%
  ungroup()

# calculate years pro
years_pro_df <- load_player_stats(seasons = c(1999:2023)) %>% filter(position %in% c("WR", "TE")) %>% select(position, player_id, season) %>% group_by(player_id, season) %>% summarize(n_weeks = n()) %>% group_by(player_id) %>% arrange(player_id, season) %>% mutate(years_pro = season - first(season)) %>% select(player_id, season, years_pro)

# add years pro to master
MASTER <- MASTER %>% left_join(years_pro_df, by = c("player_id", "season"))

# fill in every NA in MASTER with 0
# TODO: find a better solution for that
MASTER <- data.frame(lapply(MASTER, function(x) ifelse(is.na(x), 0, x)))

# plot of points per game last year vs points per game this year
ggplot(MASTER, aes(x = points_pg_ly, y = points_per_game)) + geom_point() + geom_smooth(method = "lm", se = F)

```


```{r}
# find "last team" of wide receivers
wr_last_team <- wrs %>% group_by(player_id, season) %>% filter(week == max(week)) %>% mutate(last_team_last_year = recent_team) %>% select(player_id, season, last_team_last_year) %>% arrange(player_id, season)


wr_first_team <- wrs %>% group_by(player_id, season) %>% filter(week == min(week)) %>% mutate(starting_team = recent_team) %>% select(player_id, season, starting_team)

wr_last_team$for_season <- wr_last_team$season + 1
wr_last_team$season <- NULL

wr_team_history <- NULL
wr_team_history <- left_join(wr_first_team, wr_last_team, by = c("player_id", c("season" = "for_season")))


season_attempts_last_year <- d2010_to_2022 %>%
  filter(season_type == "REG") %>%
  group_by(season, recent_team) %>%
  summarize(total_attempts_ly = sum(attempts)) %>%
  mutate(season = season + 1)


wr_attempt_table <- wr_team_history %>% left_join(season_attempts_last_year, by = c("season", c("starting_team" = "recent_team")))

wr_attempt_table <- wr_attempt_table %>% rename(pass_attempts_new_team = total_attempts_ly)

wr_attempt_table <- wr_attempt_table %>% left_join(season_attempts_last_year, by = c("season", c("last_team_last_year" = "recent_team")))

wr_attempt_table <- wr_attempt_table %>% rename(pass_attempts_old_team = total_attempts_ly) %>% mutate(pass_attempt_difference = pass_attempts_new_team - pass_attempts_old_team)


wr_attempt_table$pass_attempt_difference <- ifelse(is.na(wr_attempt_table$pass_attempt_difference), 0, wr_attempt_table$pass_attempt_difference)

# TODO: add indicator variable if on a new team or not:
wr_attempt_table$is_on_new_team <- ifelse(wr_attempt_table$pass_attempt_difference == 0, "no", "yes")

MASTER <- wr_attempt_table %>% select(player_id, season, pass_attempt_difference, starting_team, is_on_new_team) %>% right_join(MASTER, by = c("player_id", "season"))
```


```{r}
# draft pick status:
draft_history <- load_draft_picks() %>% filter(position %in% c("WR", "TE"))

# read in draft info fix
gsis <- read_csv("draftinfo_gsis_fix.csv")

draft_history <- gsis %>% select(pfr_player_name, gsis_id) %>% right_join(draft_history, by = "pfr_player_name")
draft_history$gsis_id.y <- ifelse(is.na(draft_history$gsis_id.y), draft_history$gsis_id.x, draft_history$gsis_id.y)

draft_history$player_id <- draft_history$gsis_id.y

# joining in pick info for players in master
MASTER <- draft_history %>% select(pfr_player_id, pfr_player_name, player_id, pick, round) %>% right_join(MASTER, by = "player_id")

## testing: fill UDFA with 0 and then inspect:
ggplot(MASTER, aes(x = pick, y = points_per_game)) + geom_point() + geom_smooth(method = "lm", se = F)

# visuallizing points per game by drafted / undrafted
ggplot(data = MASTER) +
  geom_violin(aes(x = ifelse(is.na(pick), "Undrafted", "Got Drafted"), y = points_per_game)) +
  labs(x = "Pick Availability", y = "Points Per Game") +
  ggtitle("Boxplot of Points Per Game by Pick Availability")

# filling NA with 300 for undfrafteds
MASTER <- MASTER %>% mutate(pick = ifelse(is.na(pick), 300, pick))
```

```{r}
# TODO: include wr/te as variable in master
positions <- wrs %>% group_by(player_id, position) %>% summarize(remove = n()) %>% select(player_id, position) %>% filter(player_id != "00-0036145")

#adding positions to master
MASTER <- MASTER %>% left_join(positions, by = "player_id")
#adding teams to master:
# need to rename team names for history
drafting_teams <- unique(draft_history$team)
# getting teams in master
master_teams <- unique(wr_attempt_table$starting_team)
# get list of teams in drafting that are NOT in master
drafting_teams[which(!(drafting_teams %in% master_teams))]
master_teams[which(!(master_teams %in% drafting_teams))]


draft_history <- draft_history %>% mutate(team = recode(team, 
            "GNB" = "GB",
            "STL" = "LA",
            "KAN" = "KC",
            "NOR" = "NO",
            "SFO" = "SF",
            "NWE" = "NE",
            "OAK" = "LV",
            "SDG" = "LAC",
            "TAM" = "TB",
            "LAR" = "LA",
            "LVR" = "LV"))

# cleaning draft_history
draft_history <- draft_history %>% select(season, pick, team, position, player_id) 
# TODO: calculate draft capital invested on WR
decay_rate <- .013
draft_capital_calculator <- draft_history %>% mutate(pick_investment = exp(-.013 * pick))
#plotting what that invesment looks like
ggplot(draft_capital_calculator, aes(x=pick, y = pick_investment)) + geom_point() + labs(title = "visualizing investment score from the pick")

pick_investment_grouped <- draft_capital_calculator %>% group_by(team, season, position) %>% summarize(total_positional_investment = round(sum(pick_investment),2)) %>% filter(position %in% c("WR", "TE"))


# fill in all NA values of position with WR
MASTER$position <- replace(MASTER$position, is.na(MASTER$position), "WR")
# adding in pick investment to master
MASTER <- MASTER %>% left_join(pick_investment_grouped, by = c("season", "position", c("starting_team" = "team")))
# fill NA pick investment to 0
MASTER$total_positional_investment <- replace(MASTER$total_positional_investment, is.na(MASTER$total_positional_investment), 0)

# adjusting investment to ignore YOURSELF
MASTER <- MASTER %>%
  left_join(draft_history, by = c("player_id", "season"), suffix = c("", "_DEL")) %>%
  mutate(adjustment = ifelse(!is.na(pick_DEL), exp(-decay_rate * pick_DEL), 0)) %>% mutate(total_positional_investment = round(total_positional_investment - adjustment, 2)) %>% select(-pick_DEL, -position_DEL, -team, -adjustment)

MASTER$total_positional_investment <- ifelse(MASTER$total_positional_investment > 0, MASTER$total_positional_investment, 0)

summary(MASTER)
```



```{r}
wr_by_yr <- wrs %>%
  group_by(player_id, season) %>%
  summarize(targets = sum(targets),
            fantasy_pts = sum(fantasy_points_ppr),
            final_team = recent_team[which.max(week)],
            starting_team = recent_team[which.min(week)]) %>%
  mutate(targets = ifelse(season < 2021, targets * 17/16, targets),
         fantasy_pts = ifelse(season < 2021, fantasy_pts * 17/16, fantasy_pts)) %>%
  arrange(player_id, season, final_team) %>%  # Sort the data for correct lagging
  mutate(targets_same_team_last_year = ifelse(
    player_id == lag(player_id) & starting_team == lag(final_team) & season == lag(season) + 1,
    lag(targets),
    NA
  ),
  targets_for_new_team = ifelse(
    player_id == lag(player_id) & starting_team != lag(final_team) & season == lag(season) + 1,
    lag(targets),
    NA
  ),
  fp_same_team_last_year = ifelse(
    player_id == lag(player_id) & starting_team == lag(final_team) & season == lag(season) + 1,
    lag(fantasy_pts),
    NA
  ),
  fp_for_new_team = ifelse(
    player_id == lag(player_id) & starting_team != lag(final_team) & season == lag(season) + 1,
    lag(fantasy_pts),
    NA
  )
  )

tm_targets_remaining <- wr_by_yr %>% group_by(starting_team, season) %>% summarize(remaining_targets_last_year = sum(targets_same_team_last_year, na.rm = T), targets_added_this_year = sum(targets_for_new_team, na.rm = T),
remaining_fp_last_year = sum(fp_same_team_last_year, na.rm = T),
fp_added_this_year = sum(fp_for_new_team, na.rm = T))

#  the ty montgomery rule: subtract 120 fantasy points from the 2017 packers
tm_targets_remaining <- tm_targets_remaining %>% mutate(remaining_fp_last_year = ifelse(starting_team == "GB" & season == 2016, 940, tm_targets_remaining$remaining_fp_last_year))

tm_targets_remaining <- tm_targets_remaining %>% mutate(remaining_targets_last_year = ifelse(starting_team == "GB" & season == 2016, 510, tm_targets_remaining$remaining_targets_last_year))



targets_last_yr <- wr_by_yr %>% group_by(final_team, season) %>% summarize(total_targets_last_year = sum(targets), total_fp_last_year = sum(fantasy_pts))

targets_last_yr$season <- targets_last_yr$season + 1

target_dropoff <- tm_targets_remaining %>% left_join(targets_last_yr, by = c("season", c("starting_team" = "final_team"))) %>% select(starting_team, season, remaining_targets_last_year, total_targets_last_year, targets_added_this_year, total_fp_last_year, remaining_fp_last_year, fp_added_this_year) %>% mutate(target_dropoff =  total_targets_last_year - remaining_targets_last_year, fp_dropoff = total_fp_last_year - remaining_fp_last_year)




MASTER <- MASTER %>% left_join(target_dropoff, by = c("season", c("starting_team" = "starting_team")))
MASTER <- MASTER %>% select(-remaining_targets_last_year, -total_targets_last_year, -total_fp_last_year, -remaining_fp_last_year)

## DOUBLE CHECK THIS WORKS BEFORE PROCEEDING

#if you're on a new team, subtract your targets last year from the teamwide "new targets added" column
# THIS IS BROKEN SOMEHOW. NOT SURE HOW.
MASTER$targets_added_this_year <- ifelse(MASTER$is_on_new_team == 1, MASTER$targets_added_this_year - MASTER$targets_ly, MASTER$targets_added_this_year)

MASTER$fp_added_this_year <- ifelse(MASTER$is_on_new_team == 1,
MASTER$fp_added_this_year - MASTER$total_pts_ly, MASTER$fp_added_this_year)

```

```{r}
# how well does draft position predict performance for rookies???
rookies <- MASTER %>%
  group_by(player_id) %>%
  filter(season == min(season))

non_rookies <- MASTER %>%
  anti_join(rookies, by = c("player_id", "season"))

drafted_rookies <- rookies %>% filter(pick < 300)
ggplot(drafted_rookies, aes(x = pick, y = points_per_game, color = position)) + geom_point() + geom_smooth()

ggplot(rookies, aes(x=factor(round), y = points_per_game)) + geom_violin()

```


```{r}
# COMBINE DATA

# assuming 6 clusters for WR and 4 for TE
combine_data <- load_combine()
names(combine_data)
pfr_to_gsis <- load_ff_playerids() %>% select(gsis_id, pfr_id) %>% distinct(pfr_id, gsis_id)
pfr_to_gsis <- pfr_to_gsis %>% filter(!is.na(pfr_id))
combine_data <- combine_data %>% filter(!is.na(pfr_id)) %>% filter(pos %in% c("WR", "TE"))
combine_data <- combine_data %>% left_join(pfr_to_gsis, by = "pfr_id")
summary(factor(combine_data$gsis_id))

# 2 instances:
test <- combine_data %>% filter(pfr_id %in% c("BrowCh03", "BrowPh00"))

names(combine_data)

# select the relevant cols
combine_data <- combine_data %>% select(ht, wt, forty, cone, vertical, shuttle, gsis_id, pfr_id, pos)


combine_data <- combine_data %>%
  separate(ht, into = c('ft', 'inc'), sep = "-") %>%
  mutate(ft = as.numeric(ft), inc = as.numeric(inc), ht_in = (ft * 12) + inc) %>%
  select(-ft, -inc)



# inspecting missing columns
vis_miss(combine_data)

non_id_cols <- c("wt", "forty", "cone", "vertical", "shuttle", "ht_in")
completed_rows <- complete.cases(combine_data[,non_id_cols])
complete_combine <- combine_data[completed_rows ,]
missing_combine <- combine_data[!completed_rows ,]

complete_combine_wr <- complete_combine %>% filter(pos == "WR")
complete_combine_te <- complete_combine %>% filter(pos == "TE")
missing_combine_wr <- missing_combine %>% filter(pos == "WR")
missing_combine_te <- missing_combine %>% filter(pos == "TE")
# creating clustering algo based on complete cases.
# Center and scale the data
scaled_data_wr <- scale(complete_combine_wr %>% select(-gsis_id, -pfr_id, -pos))
scaled_data_te <- scale(complete_combine_te %>% select(-gsis_id, -pfr_id, -pos))
# Calculate the Euclidean distance matrix

dist_matrix_te <- dist(scaled_data_te, method = "euclidean")
dist_matrix_wr <- dist(scaled_data_wr, method = "euclidean")

# Perform hierarchical clustering
hc_wr <- hclust(dist_matrix_wr)
hc_te <- hclust(dist_matrix_te)
# Initialize an empty vector to store SSD values
ssd <- c()
# Loop through different numbers of clusters (2 to a reasonable maximum)
for (k in 1:10) {
  kmeans_model_wr <- kmeans(dist_matrix_wr, centers = k)
  ssd[k] <- kmeans_model_wr$tot.withinss
}
# Plot the SSD values against the number of clusters
plot(1:10, ssd, type = "b", 
     xlab = "Number of Clusters (K)", ylab = "Sum of Squared Distances (SSD)")
title("Elbow Plot")

set.seed(1)
# with 4 clusters, lets get the clusters
kmeans_model_wr <- kmeans(scaled_data_wr, centers = 6)
kmeans_model_te <- kmeans(scaled_data_te, centers = 4)
# Get cluster assignments for each data point
cluster_labels_wr <- kmeans_model_wr$cluster
cluster_labels_te <- kmeans_model_te$cluster + 6

complete_combine_wr$cluster <- cluster_labels_wr
complete_combine_te$cluster <- cluster_labels_te

clusterbreakdown <- complete_combine_wr %>% group_by(cluster) %>% summarize(mean_wt = mean(wt), mean_forty = mean(forty), mean_cone = mean(cone), mean_vertical = mean(vertical), mean_shuttle = mean(shuttle), mean_ht = mean(ht_in), count = n())


# applying to "missing combine"
missing_combine_scaled_wr <- as.data.frame(scale(missing_combine_wr %>% select(-gsis_id, -pfr_id, -pos)))
missing_combine_scaled_te <- as.data.frame(scale(missing_combine_te %>% select(-gsis_id, -pfr_id, -pos)))

# working centers:
centers_wr <- data.frame(kmeans_model_wr$centers)
centers_te <- data.frame(kmeans_model_te$centers)

results_wr <- data.frame(rownum = 0, cluster = 0, dist = 0)
results_te <- data.frame(rownum = 0, cluster = 0, dist = 0)
# looping through each row in missing combine
for (center_row in 1:nrow(centers_wr)) {
  cluster_to_test <- centers_wr[center_row,]
  for (i in 1:nrow(missing_combine_scaled_wr)) {
    row <- missing_combine_scaled_wr[i,]
    row_d <- c()
    for (col in colnames(row)) {
      single_col_d <- 0
      if (!is.na(row[,col])) {
        single_col_d <- sqrt((row[,col] - cluster_to_test[,col])^2)
      }
      row_d <- c(row_d, single_col_d)
    }
    total_dist_row <- sum(row_d)
    to_add <- data.frame(rownum = i,
                         cluster = center_row,
                         dist = total_dist_row)
    results_wr <- rbind(results_wr, to_add)
  }
}
for (center_row in 1:nrow(centers_te)) {
  cluster_to_test <- centers_te[center_row,]
  for (i in 1:nrow(missing_combine_scaled_te)) {
    row <- missing_combine_scaled_te[i,]
    row_d <- c()
    for (col in colnames(row)) {
      single_col_d <- 0
      if (!is.na(row[,col])) {
        single_col_d <- sqrt((row[,col] - cluster_to_test[,col])^2)
      }
      row_d <- c(row_d, single_col_d)
    }
    total_dist_row <- sum(row_d)
    to_add <- data.frame(rownum = i,
                         cluster = center_row,
                         dist = total_dist_row)
    results_te <- rbind(results_te, to_add)
  }
}

# get rid of blank test row
results_wr <- results_wr %>% filter(rownum > 0)
results_te <- results_te %>% filter(rownum > 0)

assignments_wr <- results_wr %>%
  group_by(rownum) %>%  # Group by 'rownum'
  slice(which.min(dist)) %>%  # Select rows with the minimum 'dist'
  ungroup() %>%  # Remove grouping
  select(rownum, cluster)  %>% # Select 'rownum' and 'cluster' column
  arrange(rownum)

assignments_te <- results_te %>%
  group_by(rownum) %>%  # Group by 'rownum'
  slice(which.min(dist)) %>%  # Select rows with the minimum 'dist'
  ungroup() %>%  # Remove grouping
  select(rownum, cluster)  %>% # Select 'rownum' and 'cluster' column
  arrange(rownum)


missing_combine_wr$cluster <- assignments_wr$cluster 
missing_combine_te$cluster <- assignments_te$cluster + 6

#missing_combine_breakdown <- missing_combine %>% group_by(cluster) %>% summarize(mean_wt = mean(wt, na.rm=T), mean_forty = mean(forty, na.rm=T), mean_cone = mean(cone,na.rm=T), mean_vertical = mean(vertical, na.rm=T), mean_shuttle = mean(shuttle, na.rm=T), mean_ht = mean(ht_in, na.rm=T))

full_combine_clustered <- rbind(missing_combine_wr, complete_combine_wr, missing_combine_te, complete_combine_te) %>% rename(combine_cluster = cluster) %>% select(combine_cluster, gsis_id, pfr_id)
```

```{r}
# joining cluster assignments to master
MASTER <- MASTER %>% left_join(full_combine_clustered, by = c("player_id" = "gsis_id"))

MASTER$combine_cluster <- ifelse(is.na(MASTER$combine_cluster), "no_combine_cluster", MASTER$combine_cluster)

MASTER$combine_cluster <- factor(MASTER$combine_cluster)

summary(factor(MASTER$combine_cluster))
```

```{r}
# depth chart explortation
depth_charts <- load_depth_charts(seasons = c(2010:2023)) %>% filter(week == 1, position == "QB", depth_team == 1, formation == "Offense")

espn_qbr <- load_espn_qbr(league = "nfl", seasons = c(2010:2023), summary_type = "season") %>% filter(season_type == "Regular", qualified == "TRUE")

espn_qbr <- espn_qbr %>% arrange(player_id, season) %>%
  group_by(player_id) %>% mutate(starter_qbr_ly = lag(qbr_total, n=1),
starter_epa_passing_ly = lag(pass, n=1), starter_total_snaps_ly = lag(qb_plays, n=1), starter_epa_persnap_passing_ly = starter_epa_passing_ly / starter_total_snaps_ly) %>% ungroup()



# adjust epa_passing_ly by 17/16 if season was before 2022
espn_qbr$starter_epa_passing_ly <- ifelse(espn_qbr$season < 2022, espn_qbr$starter_epa_passing_ly * (17/16), espn_qbr$starter_epa_passing_ly)


# showing distribution of starter qbr
ggplot(espn_qbr, aes(starter_qbr_ly)) + geom_density()

# fixing espn naming convention on teams
espn_qbr <- espn_qbr %>% mutate(team_abb = recode(team_abb, 
           "SD" = "LAC",
           "STL" = "LA",
           "WSH" = "WAS",
           "LAR" = "LA",
           "OAK" = "LV"))

depth_charts <- depth_charts %>% mutate(club_code = recode(club_code, 
              "SD" = "LAC",
              "STL" = "LA"
              ))

# pulling in qb ids to join
qb_ids <- load_ff_playerids() %>% filter(position == "QB") %>% select(espn_id, gsis_id)

# add gsis to espn_qbr
espn_qbr <- espn_qbr %>% left_join(qb_ids, by = c("player_id" = "espn_id"))

# getting rid of any qb that wasnt the week 1 starter
espn_qbr <- espn_qbr %>%
  semi_join(depth_charts, by = c("season", "gsis_id", c("team_abb" = "club_code")))



percentiles <- seq(0, 1, by = 0.125)
bin_edges <- quantile(espn_qbr$starter_qbr_ly, percentiles, na.rm=T)

# Create bins based on percentiles
espn_qbr$qbr_ly_bin <- cut(espn_qbr$starter_qbr_ly, breaks = bin_edges, labels = FALSE)

#make a new bin for NA qbs too
espn_qbr$qbr_ly_bin <- ifelse(is.na(espn_qbr$qbr_ly_bin), "no_history", espn_qbr$qbr_ly_bin)

# converting from number to string
espn_qbr$qbr_ly_bin <- as.character(espn_qbr$qbr_ly_bin)

espn_qbr <- espn_qbr %>% select(season, team_abb, starter_qbr_ly, qbr_ly_bin, starter_epa_persnap_passing_ly, starter_epa_passing_ly)

MASTER <- MASTER %>% left_join(espn_qbr, by = c("season", c("starting_team" = "team_abb"))) %>% distinct()


summary(factor(MASTER$qbr_ly_bin))
# fill all other na's with "other" for now
MASTER$qbr_ly_bin <- ifelse(is.na(MASTER$qbr_ly_bin), "other", MASTER$qbr_ly_bin)

# fill starter_epa_persnap_passing_ly and starter_epa_passing_ly with 0s
MASTER$starter_epa_persnap_passing_ly[is.na(MASTER$starter_epa_persnap_passing_ly)] <- 0
MASTER$starter_epa_passing_ly[is.na(MASTER$starter_epa_passing_ly)] <- 0

```




```{r}
# this chunk creates "team_fp_ly"
qb_fantasy_pts <- load_player_stats(seasons = c(2010:2023)) %>% select(player_id, player_name, season, week, fantasy_points_ppr, recent_team, passing_yards, passing_tds) %>% group_by(season, recent_team) %>% summarize(total_passing_tds_ly = sum(passing_tds), total_passing_yds_ly = sum(passing_yards)) %>% mutate(total_passing_fp_ly = (total_passing_tds_ly * 4) + (total_passing_yds_ly / 25))  %>% mutate(season = season + 1)


MASTER <- MASTER %>% left_join(qb_fantasy_pts, by = c(c("starting_team" = "recent_team"), "season"))


```


```{r}
# get head coach info
hcs <- read.csv("hcs_2000_to_2023.csv") %>% select(-X)

# should all be 32.
num_hcs_per_yr <- hcs %>% group_by(year) %>% summarize(num_hcs = n())

hcs <- hcs %>% mutate(team = recode(team, 
            "GNB" = "GB",
            "STL" = "LA",
            "KAN" = "KC",
            "NOR" = "NO",
            "SFO" = "SF",
            "NWE" = "NE",
            "OAK" = "LV",
            "SDG" = "LAC",
            "TAM" = "TB",
            "LAR" = "LA",
            "LVR" = "LV"))

hcs <- hcs %>%
  arrange(coach, team, year) %>%
  mutate(is_returning_coach = ifelse(
    coach == lag(coach) & team == lag(team) & year - 1 == lag(year),
    1,
    0
  )) %>% group_by(coach, team) %>%
  mutate(hc_years_with_team = row_number())


# get rid of the one NA is_returning_coach
hcs$is_returning_coach <- ifelse(is.na(hcs$is_returning_coach), 0, hcs$is_returning_coach)

# join head coaches to master
MASTER <- MASTER %>% left_join(hcs, by = c(c("season"="year"), c("starting_team"="team")))

```


```{r}

is_old_nfl <- MASTER$season < 2021
adjustment <- 17/16

columns_to_adjust <- c('snap_games_played', 'total_targets', 'total_pts', 'total_wopr', 'total_rec', 'season_snaps')

for (column in columns_to_adjust) {
  MASTER[[column]] <- ifelse(is_old_nfl, MASTER[[column]] * adjustment, MASTER[[column]])
}

# doing the same adjustment but for last year
ly_columns_to_adjust <- c("total_passing_tds_ly", "total_passing_fp_ly", "total_passing_yds_ly", "total_games_ly", "targets_ly", "total_snaps_ly", "total_pts_ly", "fp_added_this_year",
"fp_dropoff", "targets_added_this_year", "target_dropoff"
)

is_old_nfl_ly <- MASTER$season < 2022

for (column in ly_columns_to_adjust) {
  MASTER[[column]] <- ifelse(is_old_nfl_ly, MASTER[[column]] * adjustment, MASTER[[column]])
}

# doing the same adjustment but for 2 years ago
two_years_columns_to_adjust <- c("targets_2y", "total_games_2y")

is_old_nfl_2y <- MASTER$season < 2023

for (column in two_years_columns_to_adjust) {
  MASTER[[column]] <- ifelse(is_old_nfl_2y, MASTER[[column]] * adjustment, MASTER[[column]])
}


# get rid of rookie clause:
#MASTER <- MASTER %>% filter(years_pro == 0)
#MASTER <- MASTER %>% filter(position == "WR")

year_to_remove <- min(MASTER$season) # use 2014 if using 3yrs ago data
d2023 <- MASTER %>% filter(season == 2023)
MASTER <- MASTER %>% filter(season > year_to_remove) %>% filter(season < 2023)

# Define the variable for stratification (in this case, the "season" column)
strata_var <- MASTER$season

# Create the index for stratified sampling
set.seed(123)  # For reproducibility
trainIndex <- createDataPartition(strata_var, p = 0.7, list = FALSE)

# Split the data into training and testing sets
trainData <- MASTER[trainIndex, ]
testData <- MASTER[-trainIndex, ]

# Create a train control object for 5-fold cross-validation
ctrl <- trainControl(method = "cv", number = 5)

# custom_params <- expand.grid(
#   nrounds = c(100),         # Number of boosting rounds
#   max_depth = c(4),         # Maximum tree depth
#   eta = c(0.1),             # Learning rate
#   gamma = 0,
#   min_child_weight = 1,
#   subsample = c(0.8),       # Fraction of training data to randomly sample
#   colsample_bytree = c(0.8) # Fraction of features to randomly sample for building trees
# )


model <- train(points_per_game ~ points_pg_ly + targets_pg_ly + wopr_pg_ly + pick + air_yards_pg_ly + total_games_ly  + pass_attempt_difference  + total_positional_investment + target_dropoff + epa_pg_ly + years_pro + targets_added_this_year + is_on_new_team + points_per_snap_ly + targets_per_snap_ly + wopr_per_snap_ly + total_snaps_ly  + total_passing_tds_ly + total_passing_yds_ly + total_passing_fp_ly + is_returning_coach + hc_years_with_team + catch_rate_ly + position + fp_dropoff + starter_epa_passing_ly + starter_epa_persnap_passing_ly + combine_cluster + qbr_ly_bin, 
# removed: points_2y + total_games_2y + points_3y + total_games_3y + targets_pg_2y + targets_pg_3y + wopr_pg_2y + wopr_pg_3y +
               data = trainData, 
               method = "rf", trControl = ctrl
             #  , tuneGrid = custom_params
             )

# Make predictions on the test set
predictions <- predict(model, newdata = testData)

# Evaluate the model's performance
results <- postResample(predictions, testData$points_per_game)


testData$predicted <- predictions
trainData$predicted <- predict(model, newdata = trainData)

testData$is_testing <- 1
trainData$is_testing <- 0
### MAKING UNIFIED

post_ml_data <- rbind(testData, trainData)

ggplot(testData, aes(predicted, points_per_game)) + geom_point(color = "blue") + geom_abline(intercept = 0, slope = 1, color = "red", linewidth = 1.5) + labs(title = "predicted PPG vs Actual\nred line is PERFECT prediction", y = "actual PPG", x = "PREDICTED PPG")


# Assuming you have a column named "pfr_player_name" in your testData
gg <- ggplot(testData, aes(predicted, points_per_game, text = paste(pfr_player_name, season, starting_team, position), color = position)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red", linewidth = 1.5) +
  labs(title = "predicted PPG vs Actual\nred line is PERFECT prediction", y = "actual PPG", x = "PREDICTED PPG")

# Convert the ggplot to an interactive plot using plotly
ggplotly(gg)
print(results)

#train vs test rmse
# Calculate RMSE when is_testing == 1
rmse_testing_1 <- sqrt(mean((post_ml_data$points_per_game[post_ml_data$is_testing == 1] - post_ml_data$predicted[post_ml_data$is_testing == 1])^2))

# Calculate RMSE when is_testing == 0
rmse_testing_0 <- sqrt(mean((post_ml_data$points_per_game[post_ml_data$is_testing == 0] - post_ml_data$predicted[post_ml_data$is_testing == 0])^2))
rmse_testing_1  
rmse_testing_0 

```


```{r}
# COMPARING TO MIKE CLAY:
espn_2023 <- read_csv("espn_2023.csv")

d2023_predictions <- predict(model, newdata = d2023)

to_espn <- d2023
to_espn$predicted_ppg <- d2023_predictions

#selecting only relevant columns for comparison:
to_espn <- to_espn %>% select(predicted_ppg, player_id, pfr_player_name, starting_team, total_pts, points_per_game)

to_espn$our_residual <- to_espn$predicted_ppg - to_espn$points_per_game

espn_2023 <- espn_2023 %>% left_join(to_espn, by = c("gsis_id" = "player_id")) %>% select(player, espn_ppg_projected, predicted_ppg, points_per_game, our_residual, position, gsis_id, starting_team, total_pts)



# Calculate the squared differences
squared_diff <- (espn_2023$points_per_game - espn_2023$espn_ppg_projected)^2
# Calculate the mean of squared differences
mean_squared_diff <- mean(squared_diff)
# Calculate RMSE
rmse <- sqrt(mean_squared_diff)
rmse

squared_diff_us <- (espn_2023$points_per_game - espn_2023$predicted_ppg)^2
# Calculate the mean of squared differences
mean_squared_diff_us <- mean(squared_diff_us)
# Calculate RMSE
rmse_us <- sqrt(mean_squared_diff_us)

#comparing
rmse
rmse_us

ggplot(espn_2023, aes(x = espn_ppg_projected, fill = "ESPN PPG Projected")) +
  geom_density(alpha = 0.5) +
  geom_density(aes(x = predicted_ppg, fill = "Our Predicted PPG"), alpha = 0.5) +
  labs(title = "Density Plot of ESPN PPG Projected and Our Predicted PPG",
       x = "PPG",
       y = "Density") +
  scale_fill_manual(values = c("ESPN PPG Projected" = "blue", "Our Predicted PPG" = "red"))

```


```{r}
# variable importance:
importance <- varImp(model)

# Step 3: Create a dalex model
dalex_model <- explain(model = model,
                       data = MASTER,
                       y = MASTER$points_per_game,
                       predict_function = predict)



plot(importance)

prof <- model_profile(dalex_model, type = "accumulated", variable = "points_pg_ly")
plot(prof)

#Examine interaction between num/cat or cat/cat variables (see variables in numerics and cats created above)

profile_group <- model_profile(explainer = dalex_model,
variables = c("points_pg_ly"), groups = "is_on_new_team", type = "partial") 
plot(profile_group)

# 
profile_group <- model_profile(explainer = dalex_model,
variables = c("pick"), groups = "position", type = "partial") 
plot(profile_group)


prof <- model_profile(dalex_model, type = "accumulated", variable = "combine_cluster")
plot(prof)


amonra <- post_ml_data %>% filter(season == 2022, player_id == "00-0036963")
a_breakdown <- predict_parts(explainer = dalex_model, amonra, type = "break_down")
plot(a_breakdown)
# 00-0034521


# 00-0027150
# 2013 edelman
edelman <- post_ml_data %>% filter(season == 2013, player_id == "00-0027150")
e_breakdown <- predict_parts(explainer = dalex_model, edelman, type = "break_down")
plot(e_breakdown)

pitts <- d2023 %>% filter(player_id == "00-0036970")
pitts_breakdown <- predict_parts(explainer = dalex_model, pitts, type = "break_down")
plot(pitts_breakdown)





addison <- d2023 %>% filter(player_id == "00-0038544")
addison_breakdown <- predict_parts(explainer = dalex_model, addison, type = "break_down")
plot(addison_breakdown)


```


```{r}
# let's inspect how the resiudals behave as important variables change:

# remove all years in testing when the player was hurt (total games < 2)
testData <- testData %>% filter(total_games > 1)
# create residual column
testData$residual <- testData$points_per_game - testData$predicted

# 1: ppg LY
ggplot(testData, aes(x=points_pg_ly, y = residual)) + geom_point() + geom_smooth()

# 2: pick
ggplot(testData, aes(x=pick, y = residual)) + geom_point() + geom_smooth()

# 3: target dropoff
ggplot(testData, aes(x=target_dropoff, y = residual)) + geom_point() + geom_smooth()

# wopr pg ly
# 1: ppg LY
ggplot(testData, aes(x=wopr_pg_ly, y = residual)) + geom_point() + geom_smooth()

ggplot(testData, aes(x=factor(years_pro), y = residual)) + geom_boxplot() + geom_smooth()



```


```{r}
# can we inspect the 2022 season
test2022 <- post_ml_data %>% filter(season == 2022, position == "WR")
```

```{r}
# biggest misses check: 
testData$residual <- testData$points_per_game - testData$predicted

a <- testData %>% arrange(desc(abs(residual))) %>% select(starting_team, pfr_player_name, season, points_per_game, predicted, residual, total_games, points_pg_ly, player_id, years_pro) %>% head(20)

b <- wrs %>% filter(player_id %in% a$player_id, season %in% a$season)
```


```{r}
# investigating michael thomas vs garret wilson

# both did well their rookie years (17ppg MT, 13 GW)
# but MT was proj 7 and GW only projected 3. why?
# MT = 00-0032765
# GW = 00-0037740
mt_vs_gw <- post_ml_data %>% filter((player_id == "00-0037740" & season == 2022) | (player_id == "00-0032765" & season == 2016))
#why tf was garrett wilson undrafted?????

```

```{r}
# QUICK: print the long career ppl
print(wr_by_season %>% group_by(player_id) %>% summarize(c = n()) %>% arrange(desc(c)))

# how many unique pass catchers do we have??
distinct_player_count <- wrs %>% distinct(player_id) %>% nrow()


print(wrs %>% filter(player_id == "00-0024221"))

# show me all players who didnt play in 2021
no2021 <- MASTER %>% filter(season == 2022, points_from_last_year == 0)

```


```{r}
# Install and load the necessary library
library(rvest)


years_to_scrape <- as.character(seq(2000, 2023))

# List to store the data for each year
all_coaching_data_2 <- list()

# Loop through each year
for (year in years_to_scrape) {
  # Create the URL for the current year
  current_url <- paste0("https://www.pro-football-reference.com/years/", year, "/coaches.htm")
  
  # Read the HTML content from the current URL
  page <- read_html(current_url)
  
  # Extract and store the coaching data for the current year
  coaching_data <- page %>%
    html_table(header = TRUE) %>%
    .[[1]]
  
        # fixing column names
  colnames(coaching_data)[1] <- "coach"
  colnames(coaching_data)[2] <- "team"
  colnames(coaching_data)[3] <- "games_this_year"
  colnames(coaching_data)[7] <- "total_games_coached"
  
  coaching_data <- coaching_data %>% select(coach, team, games_this_year, total_games_coached) %>% filter(coach != "Coach")
  
  all_coaching_data_2[[year]] <- coaching_data

}

# Assuming all_coaching_data is your list of data frames
combined_data <- bind_rows(all_coaching_data, .id = "year") %>%
  mutate(year = as.integer(year)) 

# need to get only the head coaches
result <- combined_data %>%
  group_by(team, year) %>%
  slice(which.max(total_games_coached)) %>% ungroup() %>% arrange(total_games_coached)


```


```{r}
#TODO: figure out a workaround of gsis id missing values
looking_at_nas <- <- %>% filter(season > 2000) %>% filter(is.na(gsis_id)) %>% filter(position %in% c("WR", "TE")) %>% select(season, round, pick, team, gsis_id, cfb_player_id, pfr_player_name, position)

write.csv(looking_at_nas, "/Users/max/Downloads/missing_draft_info.csv", row.names =  F)
# limit to just wr/te in dataset
draft_history <- draft_history %>% filter(gsis_id %in% wrs$player_id)
draft_history_to_join <- draft_history %>% select(round, pick, gsis_id)


MASTER <- MASTER %>% left_join(draft_history_to_join, by = c("player_id" = "gsis_id"))

player_names <- wrs %>%
  select(player_id, player_name, position, season, receptions, recent_team, receiving_yards) %>%
  group_by(player_id) %>%  # Group by player_id
  filter(season == min(season)) %>%  # Filter for rows with the minimum season for each player_id
  group_by(player_id, player_name, position, season, recent_team) %>%
  summarize(yr_rec = sum(receptions),
            yr_yds = sum(receiving_yards))
write.csv(player_names, "/Users/max/Downloads/master_broken_draft_info.csv", row.names = F)


```



```{r}
db_fpecr <- read_csv("Downloads/db_fpecr.csv")
competition_ranks <- db_fpecr %>% filter(ecr_type == "ro", month(scrape_date) == 8, pos %in% c("WR", "TE"))
summary(competition_ranks)

competition_ranks$year <- year(competition_ranks$scrape_date)


#https://fantasyfootballcalculator.com/adp/ppr/12-team/wide-receiver/2022
url <- "https://fantasyfootballcalculator.com/adp/ppr/12-team/wide-receiver/2022"

# Read the webpage
response <- GET(url)

# Extract the data you need (you may need to inspect the HTML of the website to determine the CSS selector)
data <- webpage %>%
  html_nodes(".table-wrapper table") %>%  # Use the appropriate CSS selector to target the table
  html_table()

```

